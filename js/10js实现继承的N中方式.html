<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
  // 首先每个函数都有一个prototype属性。该属性是一个对象。这个对象包含一个constructor属性，这个属性指向函数本身
  // a instanceof A，需要判断a[proto] 是否在原行链上
  function User() {
    this.age = 12
    this.say = function () {
      console.log("hello")
    }
  }

  User.prototype.log = function () {
    console.log(this.age)
  }
  //
  // // 1. 通过prototype实现继承,缺点:不能复用构造函数
  // function Tom() {
  // }
  //
  // Tom.prototype = new User()
  // Tom.prototype.constructor = Tom
  // let tom = new Tom();
  // tom.log();
  // tom.say();
  // console.log("tom instanceof User:", tom instanceof User) // true
  // console.log("tom instanceof Tom:", tom instanceof Tom) // true
  // // 2. 通过apply实现继承，缺点，不能使用User原型链上的方法
  // function Jerry(a) {
  //   User.apply(this, arguments);
  // }
  //
  // let jerry = new Jerry("aa")
  // console.log("jerry instanceof User", jerry instanceof User) // false
  // // 将第一和第二结合.缺点是会有两份属性
  // function Spike(a) {
  //   User.apply(this, arguments)
  // }
  //
  // Spike.prototype = new User();
  // Spike.prototype.constructor = Spike

  // 混合继承
  function BlackCat() {
    User.apply(this, arguments)
  }

  BlackCat.prototype = User.prototype
  BlackCat.prototype.constructor = BlackCat;
  let blackCat = new BlackCat();
  console.log(blackCat)
  console.log("blackCat instanceof User",blackCat instanceof User) // true

</script>
</body>
</html>